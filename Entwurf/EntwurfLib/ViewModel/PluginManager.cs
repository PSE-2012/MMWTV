//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace ViewModel
{
	using Model;
	using Plugins;
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;

	/// <remarks>
	/// Falls es nur einen Plugin geben soll, z.b. Presentation.. 
	/// Wie soll man nach dem Plugin fragen ?
	/// 
	/// Ich denke wir können getPlugin mit dem PluginType als argument aufrufen und dann eine ensprechende Sonderbehandlung beachten
	/// 
	/// </remarks>
	/// <remarks>implementierungsdetail: keine Collection sondern readOnlyCollection zurückgeben ( bei der getPluginKeys) zurückgeben -> ist schöner</remarks>
	public class PluginManager
	{
		private PluginManager pluginManager
		{
			get;
			set;
		}

		private Dictionary<PluginType,Dictionary<string, IPlugin>> pluginTable
		{
			get;
			set;
		}

		private Caretaker caretaker
		{
			get;
			set;
		}

		private Path pluginPath
		{
			get;
			set;
		}

		private Dictionary<EventType><event> eventTable
		{
			get;
			set;
		}

		public virtual void loadPluginTable()
		{
			throw new System.NotImplementedException();
		}

		public virtual PluginManager getPluginManager()
		{
			throw new System.NotImplementedException();
		}

		private PluginManager()
		{
		}

		public virtual Memento getMemento(object string namePlugin, object string nameMemento)
		{
			throw new System.NotImplementedException();
		}

		public virtual IPlugin getPlugin(object string namePlugin)
		{
			throw new System.NotImplementedException();
		}

		public virtual Collection getPluginKeys(object PluginType type)
		{
			throw new System.NotImplementedException();
		}

		public virtual void addEvent(object EventType eType, object event e)
		{
			throw new System.NotImplementedException();
		}

		public virtual void addEventHandler(object EventType eType, object del handler)
		{
			throw new System.NotImplementedException();
		}

		public virtual void rmEventHandler(object EventType eType, object del handler)
		{
			throw new System.NotImplementedException();
		}

		public virtual void rmEvent(object EventType eType, object event e)
		{
			throw new System.NotImplementedException();
		}

		public virtual List<String> getMementos(object string namePlugin)
		{
			throw new System.NotImplementedException();
		}

		public virtual string getPluginKey(object PluginType type, object PluginName name)
		{
			throw new System.NotImplementedException();
		}

	}
}

